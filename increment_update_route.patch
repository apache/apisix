commit cfddd8b6489f1390de71d6853390ab7f1d841297
Author: ranxuxin001 <ran83816@126.com>
Date:   Mon Jun 19 11:39:55 2023 +0800

    increment route update for radixtree host uri, radixtree uri and radixtree uri with parameter

diff --git a/apisix/core/config_etcd.lua b/apisix/core/config_etcd.lua
index ecb76270..61113506 100644
--- a/apisix/core/config_etcd.lua
+++ b/apisix/core/config_etcd.lua
@@ -499,7 +499,7 @@ local function load_full_data(self, dir_res, headers)
             item.clean_handlers = {}
 
             if self.filter then
-                self.filter(item)
+                self.filter(item, 1, self)
             end
         end
 
@@ -551,7 +551,7 @@ local function load_full_data(self, dir_res, headers)
                 item.clean_handlers = {}
 
                 if self.filter then
-                    self.filter(item)
+                    self.filter(item, #values, self)
                 end
             end
 
@@ -695,9 +695,10 @@ local function sync_data(self)
             return false
         end
 
+        local pre_val
         local pre_index = self.values_hash[key]
         if pre_index then
-            local pre_val = self.values[pre_index]
+            pre_val = self.values[pre_index]
             if pre_val then
                 config_util.fire_all_clean_handlers(pre_val)
             end
@@ -755,7 +756,7 @@ local function sync_data(self)
         -- /plugins' filter need to known self.values when it is called
         -- so the filter should be called after self.values set.
         if self.filter then
-            self.filter(res)
+            self.filter(res, pre_val, self)
         end
 
         self.conf_version = self.conf_version + 1
diff --git a/apisix/http/route.lua b/apisix/http/route.lua
index d475646b..2feab788 100644
--- a/apisix/http/route.lua
+++ b/apisix/http/route.lua
@@ -73,6 +73,7 @@ function _M.create_radixtree_uri_router(routes, uri_routes, with_parameter)
             core.log.info("insert uri route: ",
                           core.json.delay_encode(route.value, true))
             core.table.insert(uri_routes, {
+                id = route.value.id,
                 paths = route.value.uris or route.value.uri,
                 methods = route.value.methods,
                 priority = route.value.priority,
diff --git a/apisix/http/router/radixtree_host_uri.lua b/apisix/http/router/radixtree_host_uri.lua
index 532576e5..369a54db 100644
--- a/apisix/http/router/radixtree_host_uri.lua
+++ b/apisix/http/router/radixtree_host_uri.lua
@@ -27,20 +27,28 @@ local loadstring = loadstring
 local pairs = pairs
 local cached_router_version
 local cached_service_version
-local host_router
-local only_uri_router
+local base        = require("resty.core.base")
+local clear_tab   = base.clear_tab
 
 
 local _M = {version = 0.1}
 
 
-local function push_host_router(route, host_routes, only_uri_routes)
+local function tab_cpy(t1, t2)
+    t1 = {}
+    for k, v in pairs(t2) do
+        t1[k] = v
+    end
+end
+
+
+function _M.push_host_router(route, host_routes, only_uri_routes, all_hosts, op, rdx_rt, pre_route, pre_rdx_rt)
     if type(route) ~= "table" then
         return
     end
 
     local filter_fun, err
-    if route.value.filter_func then
+    if route.value and route.value.filter_func then
         filter_fun, err = loadstring(
                                 "return " .. route.value.filter_func,
                                 "router#" .. route.value.id)
@@ -53,67 +61,213 @@ local function push_host_router(route, host_routes, only_uri_routes)
         filter_fun = filter_fun()
     end
 
-    local hosts = route.value.hosts
-    if not hosts then
-        if route.value.host then
-            hosts = {route.value.host}
-        elseif route.value.service_id then
-            local service = service_fetch(route.value.service_id)
-            if not service then
-                core.log.error("failed to fetch service configuration by ",
-                                "id: ", route.value.service_id)
-                -- we keep the behavior that missing service won't affect the route matching
-            else
-                hosts = service.value.hosts
+    local radixtree_route, pre_radixtree_route = {}, {}
+    local hosts
+    if route and route.value then
+        hosts = route.value.hosts
+        if not hosts then
+            if route.value.host then
+                hosts = {route.value.host}
+            elseif route.value.service_id then
+                local service = service_fetch(route.value.service_id)
+                if not service then
+                    core.log.error("failed to fetch service configuration by ",
+                                    "id: ", route.value.service_id)
+                    -- we keep the behavior that missing service won't affect the route matching
+                else
+                    hosts = service.value.hosts
+                end
+            end
+        end
+
+        radixtree_route = {
+            id = route.value.id,
+            paths = route.value.uris or route.value.uri,
+            methods = route.value.methods,
+            priority = route.value.priority,
+            remote_addrs = route.value.remote_addrs
+                        or route.value.remote_addr,
+            vars = route.value.vars,
+            filter_fun = filter_fun,
+            handler = function (api_ctx, match_opts)
+                api_ctx.matched_params = nil
+                api_ctx.matched_route = route
+                api_ctx.curr_req_matched = match_opts.matched
+                api_ctx.real_curr_req_matched_path = match_opts.matched._path
+            end
+        }
+
+        if rdx_rt ~= nil then
+            for k, v in pairs(radixtree_route) do
+                rdx_rt[k] = v
             end
         end
     end
 
-    local radixtree_route = {
-        paths = route.value.uris or route.value.uri,
-        methods = route.value.methods,
-        priority = route.value.priority,
-        remote_addrs = route.value.remote_addrs
-                       or route.value.remote_addr,
-        vars = route.value.vars,
-        filter_fun = filter_fun,
-        handler = function (api_ctx, match_opts)
-            api_ctx.matched_params = nil
-            api_ctx.matched_route = route
-            api_ctx.curr_req_matched = match_opts.matched
-            api_ctx.real_curr_req_matched_path = match_opts.matched._path
-        end
-    }
-
-    if hosts == nil then
+    if hosts == nil and all_hosts == nil then
         core.table.insert(only_uri_routes, radixtree_route)
         return
     end
 
-    for i, host in ipairs(hosts) do
-        local host_rev = host:reverse()
-        if not host_routes[host_rev] then
-            host_routes[host_rev] = {radixtree_route}
+    local pre_hosts
+    if pre_route and pre_route.value then
+        pre_hosts = pre_route.value.hosts
+        if not pre_hosts then
+            if pre_route.value.host then
+                pre_hosts = {pre_route.value.host}
+            elseif pre_route.value.service_id then
+                local service = service_fetch(pre_route.value.service_id)
+                if not service then
+                    core.log.error("failed to fetch service configuration by ",
+                                    "id: ", pre_route.value.service_id)
+                    -- we keep the behavior that missing service won't affect the route matching
+                else
+                    pre_hosts = service.value.hosts
+                end
+            end
+        end
+
+        pre_radixtree_route = {
+            id = pre_route.value.id,
+            paths = pre_route.value.uris or pre_route.value.uri,
+            methods = pre_route.value.methods,
+            priority = pre_route.value.priority,
+            remote_addrs = pre_route.value.remote_addrs
+                           or pre_route.value.remote_addr,
+            vars = pre_route.value.vars,
+            filter_fun = filter_fun,
+            handler = function (api_ctx, match_opts)
+                api_ctx.matched_params = nil
+                api_ctx.matched_route = pre_route
+                api_ctx.curr_req_matched = match_opts.matched
+                api_ctx.real_curr_req_matched_path = match_opts.matched._path
+            end
+        }
+
+        if pre_rdx_rt ~= nil then
+            for k, v in pairs(pre_radixtree_route) do
+                pre_rdx_rt[k] = v
+            end
+        end
+    end
+
+    if all_hosts ~= nil then
+        all_hosts["host"] = hosts
+        all_hosts["pre_host"] = pre_hosts
+    end
+
+    local pre_t = {}
+    if pre_hosts then
+        for i, h in ipairs(pre_hosts) do
+            local rev_h = h:reverse()
+            pre_t[rev_h] = 1
+        end
+    end
+
+    local t = {}
+    if hosts then
+        for i, h in ipairs(hosts) do
+            local rev_h = h:reverse()
+            t[rev_h] = 1
+        end
+    end
+
+    local comm = {}
+    for k, v in pairs(pre_t) do
+        if t[k] ~= nil then
+            tab_insert(comm, k)
+            pre_t[k] = nil
+            t[k] = nil
+        end
+    end
+
+    for _, j in ipairs(comm) do
+        local routes = host_routes[j]
+        if routes == nil then
+            core.log.error("no routes array for reverse host in the map.", j)
+            return
+        end
+
+        local found = false
+        for i, r in ipairs(routes) do
+            if r.id == radixtree_route.id then
+                routes[i] = radixtree_route
+                found = true
+                if op then
+                    table.insert(op["upd"], j)
+                end
+                break
+            end
+        end
+
+        if not found then
+            core.log.error("cannot find the route in common host's table.", j, radixtree_route.id)
+            return
+        end
+    end
+
+    for k, v in pairs(pre_t) do
+        local routes = host_routes[k]
+        if routes == nil then
+            core.log.error("no routes array for reverse host in the map.", k)
+            return
+        end
+
+        local found = false
+        for i, r in ipairs(routes) do
+            if r.id == pre_radixtree_route.id then
+                table.remove(routes, i)
+                found = true
+                break
+            end
+        end
+
+        if not found then
+            core.log.error("cannot find the route in previous host's table.", k, pre_radixtree_route.id)
+            return
+        end
+
+        if #routes == 0 then
+            host_routes[k] = nil
+            if op then
+                table.insert(op["del"], k)
+            end
+        else
+            if op then
+                table.insert(op["upd"], k)
+            end
+        end
+    end
+
+    for k, v in pairs(t) do
+        local routes = host_routes[k]
+        if routes == nil then
+            host_routes[k] = {radixtree_route}
+            if op then
+                table.insert(op["add"], k)
+            end
         else
-            tab_insert(host_routes[host_rev], radixtree_route)
+            table.insert(routes, radixtree_route)
+            if op then
+                table.insert(op["upd"], k)
+            end
         end
     end
 end
 
 
-local function create_radixtree_router(routes)
+function _M.create_radixtree_router(routes)
     local host_routes = {}
     local only_uri_routes = {}
-    host_router = nil
     routes = routes or {}
 
     for _, route in ipairs(routes) do
         local status = core.table.try_read_attr(route, "value", "status")
         -- check the status
         if not status or status == 1 then
-            push_host_router(route, host_routes, only_uri_routes)
-        end
-    end
+            _M.push_host_router(route, host_routes, only_uri_routes)
+        end 
+    end 
 
     -- create router: host_router
     local host_router_routes = {}
@@ -121,45 +275,42 @@ local function create_radixtree_router(routes)
         local sub_router = router.new(routes)
 
         core.table.insert(host_router_routes, {
+            id = 1,
             paths = host_rev,
             filter_fun = function(vars, opts, ...)
                 return sub_router:dispatch(vars.uri, opts, ...)
             end,
             handler = function (api_ctx, match_opts)
                 api_ctx.real_curr_req_matched_host = match_opts.matched._path
-            end
-        })
-    end
+            end 
+        })  
+    end 
+
+    _M.host_routes = host_routes
 
     event.push(event.CONST.BUILD_ROUTER, routes)
 
     if #host_router_routes > 0 then
-        host_router = router.new(host_router_routes)
+        _M.host_router = router.new(host_router_routes)
     end
 
     -- create router: only_uri_router
-    only_uri_router = router.new(only_uri_routes)
+    _M.only_uri_router = router.new(only_uri_routes)
+    
     return true
 end
 
 
     local match_opts = {}
 function _M.match(api_ctx)
-    local user_routes = _M.user_routes
-    local _, service_version = get_services()
-    if not cached_router_version or cached_router_version ~= user_routes.conf_version
-        or not cached_service_version or cached_service_version ~= service_version
-    then
-        create_radixtree_router(user_routes.values)
-        cached_router_version = user_routes.conf_version
-        cached_service_version = service_version
-    end
-
     return _M.matching(api_ctx)
 end
 
 
 function _M.matching(api_ctx)
+    local host_router = _M.host_router
+    local only_uri_router = _M.only_uri_router
+
     core.log.info("route match mode: radixtree_host_uri")
 
     core.table.clear(match_opts)
diff --git a/apisix/http/router/radixtree_uri.lua b/apisix/http/router/radixtree_uri.lua
index 6e546364..4c3867c4 100644
--- a/apisix/http/router/radixtree_uri.lua
+++ b/apisix/http/router/radixtree_uri.lua
@@ -17,43 +17,21 @@
 local require = require
 local core = require("apisix.core")
 local base_router = require("apisix.http.route")
-local get_services = require("apisix.http.service").services
-local cached_router_version
-local cached_service_version
+local router = require("apisix.router")
 
 
 local _M = {version = 0.2}
 
 
-    local uri_routes = {}
-    local uri_router
     local match_opts = {}
 function _M.match(api_ctx)
-    local user_routes = _M.user_routes
-    local _, service_version = get_services()
-    if not cached_router_version or cached_router_version ~= user_routes.conf_version
-        or not cached_service_version or cached_service_version ~= service_version
-    then
-        uri_router = base_router.create_radixtree_uri_router(user_routes.values,
-                                                             uri_routes, false)
-        cached_router_version = user_routes.conf_version
-        cached_service_version = service_version
-    end
-
-    if not uri_router then
-        core.log.error("failed to fetch valid `uri` router: ")
-        return true
-    end
-
     return _M.matching(api_ctx)
 end
 
 
 function _M.matching(api_ctx)
     core.log.info("route match mode: radixtree_uri")
-
-    return base_router.match_uri(uri_router, match_opts, api_ctx)
+    return base_router.match_uri(router.uri_router, match_opts, api_ctx)
 end
 
-
 return _M
diff --git a/apisix/http/router/radixtree_uri_with_parameter.lua b/apisix/http/router/radixtree_uri_with_parameter.lua
index 4bf7f3eb..e36008c8 100644
--- a/apisix/http/router/radixtree_uri_with_parameter.lua
+++ b/apisix/http/router/radixtree_uri_with_parameter.lua
@@ -17,43 +17,21 @@
 local require = require
 local core = require("apisix.core")
 local base_router = require("apisix.http.route")
-local get_services = require("apisix.http.service").services
-local cached_router_version
-local cached_service_version
+local router = require("apisix.router")
 
 
 local _M = {}
 
 
-    local uri_routes = {}
-    local uri_router
     local match_opts = {}
 function _M.match(api_ctx)
-    local user_routes = _M.user_routes
-    local _, service_version = get_services()
-    if not cached_router_version or cached_router_version ~= user_routes.conf_version
-        or not cached_service_version or cached_service_version ~= service_version
-    then
-        uri_router = base_router.create_radixtree_uri_router(user_routes.values,
-                                                             uri_routes, true)
-        cached_router_version = user_routes.conf_version
-        cached_service_version = service_version
-    end
-
-    if not uri_router then
-        core.log.error("failed to fetch valid `uri_with_parameter` router: ")
-        return true
-    end
-
     return _M.matching(api_ctx)
 end
 
 
 function _M.matching(api_ctx)
     core.log.info("route match mode: radixtree_uri_with_parameter")
-
-    return base_router.match_uri(uri_router, match_opts, api_ctx)
+    return base_router.match_uri(router.uri_router, match_opts, api_ctx)
 end
 
-
 return _M
diff --git a/apisix/router.lua b/apisix/router.lua
index 2fd14917..ec262e74 100644
--- a/apisix/router.lua
+++ b/apisix/router.lua
@@ -22,31 +22,281 @@ local plugin_checker = require("apisix.plugin").plugin_checker
 local str_lower = string.lower
 local error   = error
 local ipairs  = ipairs
+local sub_str      = string.sub
+local table        = require("apisix.core.table")
+local json         = require("apisix.core.json")
+local router_util = require("apisix.utils.router")
+local tab_insert = table.insert
+local event = require("apisix.core.event")
 
 
 local _M = {version = 0.3}
 
+local function empty_func() end
+local routes_obj, first_route
 
-local function filter(route)
+local function filter(route, pre_route_or_size, obj)
     route.orig_modifiedIndex = route.modifiedIndex
     route.update_count = 0
 
     route.has_domain = false
-    if not route.value then
-        return
+    if route.value then
+        if route.value.host then
+            route.value.host = str_lower(route.value.host)
+        elseif route.value.hosts then
+            for i, v in ipairs(route.value.hosts) do
+                route.value.hosts[i] = str_lower(v)
+            end
+        end
+
+        apisix_upstream.filter_upstream(route.value.upstream, route)
     end
 
-    if route.value.host then
-        route.value.host = str_lower(route.value.host)
-    elseif route.value.hosts then
-        for i, v in ipairs(route.value.hosts) do
-            route.value.hosts[i] = str_lower(v)
+    core.log.info("filter route: ", core.json.delay_encode(route, true))
+
+    --load_full_data()'s filter() goes here. create radixtree while etcd compacts
+    local conf = core.config.local_conf()
+    if conf.apisix.router.http == "radixtree_uri" or conf.apisix.router.http == "radixtree_uri_with_parameter" then
+        local router_opts
+        local with_parameter = false
+        if conf.apisix.router.http == "radixtree_uri" then
+            router_opts = {
+                no_param_match = true
+            }
+        else
+            with_parameter = true
+            router_opts = {
+                no_param_match = false
+            }
         end
-    end
+        
+        if type(pre_route_or_size) == "number" then
+            if pre_route_or_size == #obj.values then
+                routes_obj = obj
+                event.push(event.CONST.BUILD_ROUTER, routes_obj.values)
+                local uri_routes = {}
+                core.log.notice("create radixtree uri after load_full_data.", #routes_obj.values)
+                local uri_router = http_route.create_radixtree_uri_router(routes_obj.values, uri_routes, with_parameter)
+                if not uri_router then
+                    core.log.error("create radixtree in init worker phase failed.", #routes_obj.values)
+                    return
+                end
 
-    apisix_upstream.filter_upstream(route.value.upstream, route)
+                _M.uri_router = uri_router
+            end
 
-    core.log.info("filter route: ", core.json.delay_encode(route, true))
+            return
+        end
+
+        if not first_route then
+            routes_obj = obj
+            event.push(event.CONST.BUILD_ROUTER, routes_obj.values)
+            local uri_routes = {}
+            core.log.notice("create radixtree uri for the first route income.")
+            local uri_router = http_route.create_radixtree_uri_router(routes_obj.values, uri_routes, with_parameter)
+            if not uri_router then
+                core.log.error("create radixtree in init worker phase failed.", #routes_obj.values)
+                return
+            end
+
+            _M.uri_router = uri_router
+            first_route = true
+            return
+        end
+
+        --only sync_data()'s filter() goes here
+        event.push(event.CONST.BUILD_ROUTER, routes_obj.values)
+
+        local router_module = require("apisix.router")
+        local radixtree_obj = router_module.uri_router
+
+        local cur_route
+        if route.value then
+            local status = table.try_read_attr(route, "value", "status")
+            if status and status == 0 then
+                return
+            end
+
+            local filter_fun, err
+            if route.value.filter_func then
+                filter_fun, err = loadstring(
+                    "return " .. route.value.filter_func,
+                    "router#" .. route.value.id
+                )
+                if not filter_fun then
+                    core.log.error("failed to load filter function: ", err, " route id", route.value.id)
+                    return
+                end
+
+                filter_fun = filter_fun()
+            end
+
+            cur_route = {
+                id = route.value.id,
+                paths = route.value.uris or route.value.uri,
+                methods = route.value.methods,
+                priority = route.value.priority,
+                hosts = route.value.hosts or route.value.host,
+                remote_addrs = route.value.remote_addrs or route.value.remote_addr,
+                vars = route.value.vars,
+                filter_fun = filter_fun,
+                handler = function(api_ctx, match_opts)
+                    api_ctx.matched_params = nil
+                    api_ctx.matched_route = route
+                    api_ctx.curr_req_matched = match_opts.matched
+                end
+            }
+        end
+
+        local err
+        if pre_route_or_size then
+            local last_route = {
+                id = pre_route_or_size.value.id,
+                paths = pre_route_or_size.value.uris or pre_route_or_size.value.uri,
+                methods = pre_route_or_size.value.methods,
+                priority = pre_route_or_size.value.priority,
+                hosts = pre_route_or_size.value.hosts or pre_route_or_size.value.host,
+                remote_addrs = pre_route_or_size.value.remote_addrs or pre_route_or_size.value.remote_addr,
+                vars = pre_route_or_size.value.vars
+            }
+        
+            if route.value then
+                --update route
+                core.log.notice("update routes watched from etcd into radixtree.", json.encode(route))
+                err = radixtree_obj:update_route(last_route, cur_route, router_opts)
+                if err ~= nil then
+                    core.log.error("update a route into radixtree failed.", json.encode(route), err)
+                    return
+                end
+            else
+                --delete route
+                core.log.notice("delete routes watched from etcd into radixtree.", json.encode(route))
+                err = radixtree_obj:delete_route(last_route, router_opts)
+                if err ~= nil then
+                    core.log.error("delete a route into radixtree failed.", json.encode(route), err)
+                    return
+                end
+            end
+        elseif route.value then
+            --create route
+            core.log.notice("create routes watched from etcd into radixtree.", json.encode(route))
+            err = radixtree_obj:add_route(cur_route, router_opts)
+            if err ~= nil then
+                core.log.error("add routes into radixtree failed.", json.encode(route), err)
+                return
+            end
+        else
+            core.log.error("invalid operation type for a route.", route.key)
+            return
+        end
+    elseif conf.apisix.router.http == "radixtree_host_uri" then
+        local router_opts = {
+            no_param_match = true
+        }
+
+        local host_uri = require("apisix.http.router.radixtree_host_uri")
+        if type(pre_route_or_size) == "number" then
+            if pre_route_or_size == #obj.values then
+                routes_obj = obj
+                event.push(event.CONST.BUILD_ROUTER, routes_obj.values)
+                core.log.notice("create radixtree uri after load_full_data.", #routes_obj.values)
+                host_uri.create_radixtree_router(routes_obj.values)
+            end
+    
+            return
+        end
+
+        if not first_route then
+            routes_obj = obj
+            event.push(event.CONST.BUILD_ROUTER, routes_obj.values)
+            core.log.notice("create radixtree uri for the first route income.")
+            host_uri.create_radixtree_router(routes_obj.values)
+            first_route = true
+            return
+        end
+
+        event.push(event.CONST.BUILD_ROUTER, routes_obj.values)
+
+        local only_uri_routes = {}
+        local route_opt, pre_route_opt = {}, {}
+        local all_hosts = {}
+        local hosts, pre_hosts = nil, nil
+        local rdx_r = {}
+        local pre_rdx_r = {}
+        local op = {add={}, upd={}, del={}}
+
+
+        local status = table.try_read_attr(route, "value", "status")
+        if status and status == 0 then
+            return
+        end
+
+        -- to be confirm??? assign variable of other module.
+        host_uri.push_host_router(route, host_uri.host_routes, only_uri_routes, all_hosts, op, rdx_r, pre_route_or_size, pre_rdx_r)
+
+        hosts = all_hosts["host"]
+        if hosts ~= nil then
+            for _, h in ipairs(hosts) do
+                local host_rev = h:reverse()
+                local routes = host_uri.host_routes[host_rev]
+                local sub_router = router_util.new(routes)
+                route_opt[host_rev] = {
+                    id = 1,
+                    paths = host_rev,
+                    filter_fun = function(vars, opts, ...)
+                        return sub_router:dispatch(vars.uri, opts, ...)
+                    end,
+                    handler = empty_func,
+                }
+            end
+        end
+
+        pre_hosts = all_hosts["pre_host"]
+        if pre_hosts ~= nil then
+            for _, h in ipairs(pre_hosts) do
+                local host_rev = h:reverse()
+                pre_route_opt[host_rev] = {
+                    id = 1,
+                    paths = host_rev,
+                    filter_fun = empty_func,
+                    handler = empty_func,
+                }
+            end
+        end
+
+        for k, v in pairs(op) do
+            if k == "add" then
+                for _, j in ipairs(v) do
+                    core.log.notice("add the route with reverse host watched from etcd into radixtree.", json.encode(route), j)
+                    local r_opt = route_opt[j]
+                    host_uri.host_router:add_route(r_opt, router_opts)
+                end
+            elseif k == "upd" then
+                for _, j in ipairs(v) do
+                    core.log.notice("update the route with reverse host watched from etcd into radixtree.", json.encode(route), j)
+                    local r_opt = route_opt[j]
+                    host_uri.host_router:update_route(r_opt, r_opt, router_opts)
+                end
+            elseif k == "del" then
+                for _, j in ipairs(v) do
+                    core.log.notice("delete the route with reverse host watched from etcd into radixtree.", json.encode(route), j)
+                    local pre_r_opt = pre_route_opt[j]
+                    host_uri.host_router:delete_route(pre_r_opt, router_opts)
+                end
+            end
+        end
+
+        if (route.value and not hosts) and (not pre_route_or_size or pre_hosts) then
+            core.log.notice("add the route with uri watched from etcd into radixtree.", json.encode(route))
+            host_uri.only_uri_router:add_route(rdx_r, router_opts)
+        elseif (route.value and not hosts) and (pre_route_or_size and not pre_hosts) then
+            core.log.notice("update the route with uri watched from etcd into radixtree.", json.encode(route))
+            host_uri.only_uri_router:update_route(pre_rdx_r, rdx_r, router_opts)
+        elseif (pre_route_or_size and not pre_hosts) and (not route.value or hosts) then
+            core.log.notice("delete the route with uri watched from etcd into radixtree.", json.encode(pre_route_or_size))
+            host_uri.only_uri_router:delete_route(pre_rdx_r, router_opts)
+        end
+    end
 end
 
 
