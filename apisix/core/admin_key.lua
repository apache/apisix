local fetch_local_conf = require("apisix.core.config_local").local_conf
local try_read_attr    = require("apisix.core.table").try_read_attr
local log              = require("apisix.core.log")
local string           = string
local math             = math
local ipairs           = ipairs
local type             = type

local _M = {version = 0.1}

-- Internal structure to store all admin keys (both from config and autogenerated)
local admin_keys_cache = {}

--- Get all admin keys (from config and autogenerated)
-- @treturn table array of admin key objects with role, key, and ptional autogenerated fields
function _M.get_admin_keys()
    return admin_keys_cache
end

--- Check if admin keys are required based on configuration
-- @treturn boolean true if admin keys are required, false otherwise
function _M.admin_key_required()
    local local_conf = fetch_local_conf()
    if not local_conf.deployment then
        return true
    end

    return local_conf.deployment.admin.admin_key_required ~= false
end

--- Initialize the admin key system using shared memory for coordination
function _M.init()
    local local_conf = fetch_local_conf()

    -- Check deployment role - only initialize admin keys for traditional and control_plane modes
    local deployment_role = local_conf.deployment and local_conf.deployment.role
    if not deployment_role or (deployment_role ~= "traditional" and deployment_role ~= "control_plane") then
        log.info("skipping admin key initialization for deployment role: ", deployment_role or "undefined")
        return
    end

    local config_admin_keys = try_read_attr(local_conf, "deployment", "admin", "admin_key")

    if not config_admin_keys or type(config_admin_keys) ~= "table" then
        return
    end

    -- Use shared memory for coordination between workers
    local admin_keys_shm = ngx.shared.admin_keys
    if not admin_keys_shm then
        log.error("admin_keys shared memory zone not configured")
        return
    end

    -- Check if keys are already initialized by another worker
    local initialized = admin_keys_shm:get("initialized")

    if initialized then
        -- Load existing keys from shared memory
        _M.load_keys_from_shared_memory()
        return
    end

    -- First worker to reach here tries to acquire initialization lock
    local lock_key = "init_lock"
    local lock_value = ngx.worker.id() .. ":" .. ngx.now()

    -- Try to acquire lock (expires in 10 seconds)
    local ok, err = admin_keys_shm:safe_set(lock_key, lock_value, 10)
    if not ok then
        if err == "exists" then
            -- Another worker is initializing, wait and load
            ngx.sleep(0.1)
            _M.load_keys_from_shared_memory()
            return
        else
            log.error("failed to set lock: ", err)
            return
        end
    end

    -- Double-check initialization status after acquiring lock
    initialized = admin_keys_shm:get("initialized")
    if initialized then
        -- Another worker completed initialization while we were waiting
        admin_keys_shm:delete(lock_key)  -- Release lock
        _M.load_keys_from_shared_memory()
        return
    end

    -- We have the lock and initialization is needed
    local has_autogenerated = false

    for i, admin_key in ipairs(config_admin_keys) do
        local key_id = "admin_key_" .. i
        local key_value = admin_key.key

        if admin_key.role == "admin" and admin_key.key == "" then
            -- Log warning header only once
            if not has_autogenerated then
                log.warn("WARNING: One or more admin API keys were empty in configuration.")
                log.warn("Temporary keys have been generated for this session:")
                has_autogenerated = true
            end

            -- Generate random key
            local key = ""
            for _ = 1, 32 do
                key = key .. string.char(math.random(65, 90) + math.random(0, 1) * 32)
            end
            key_value = key

            -- Store metadata about autogenerated keys
            admin_keys_shm:set(key_id .. "_autogenerated", true)
            log.warn("  Generated admin key: ", key)
        end

        -- Store key in shared memory
        admin_keys_shm:set(key_id, key_value)
        admin_keys_shm:set(key_id .. "_role", admin_key.role)
        admin_keys_shm:set(key_id .. "_name", admin_key.name or "")
    end

    -- Store total count
    admin_keys_shm:set("total_keys", #config_admin_keys)

    -- Mark as initialized BEFORE releasing lock
    admin_keys_shm:set("initialized", true)

    -- Release lock
    admin_keys_shm:delete(lock_key)

    -- Final warning message if any keys were autogenerated
    if has_autogenerated then
        log.warn("These keys will change on every restart.")
        log.warn("Please set permanent admin_key values in conf/config.yaml.")
    end

    -- Load keys into local cache
    _M.load_keys_from_shared_memory()
end

--- Load admin keys from shared memory into local cache
function _M.load_keys_from_shared_memory()
    local admin_keys_shm = ngx.shared.admin_keys
    if not admin_keys_shm then
        return
    end

    local total_keys = admin_keys_shm:get("total_keys") or 0
    admin_keys_cache = {}

    for i = 1, total_keys do
        local key_id = "admin_key_" .. i
        local key_value = admin_keys_shm:get(key_id)
        local role = admin_keys_shm:get(key_id .. "_role")
        local name = admin_keys_shm:get(key_id .. "_name")
        local autogenerated = admin_keys_shm:get(key_id .. "_autogenerated") or false

        if key_value and role then
            local key_entry = {
                name = name ~= "" and name or nil,
                role = role,
                key = key_value,
                autogenerated = autogenerated
            }
            admin_keys_cache[#admin_keys_cache + 1] = key_entry
        end
    end
end

return _M
